---
title: "LPI-sensitivity_CAD-paper"
author: "sarah ravoth"
date: "2024-07-05"
output: html_document
---

## load packages

```{r, include = FALSE}
# install.packages("collapse")
# install.packages("scico")
library(tidyverse)
library(dplyr)
library(purrr)
library(ggplot2)
library(readr)
library(rlpi)
library(here)
library(tibble)
library(scico)
library(ggpubr)
library(RColorBrewer)
```

## load datafiles & tidy

```{r, include=FALSE}
# set working directory throughout all code chunks as homepage
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

# set source of bootstrap_by_rows() function
source(here("02_scripts","function_bootstrap_rows.R"))

# set source of calculate_index_lambdas() function
source(here("02_scripts","calculate_index_lambdas.R"))

# load data
# original canadian data
cad <- read.csv(here("00_data", "CAD_Paper_withzeroes.csv"), na.strings="NULL", header=TRUE)  %>%
  mutate(X2009 = as.character(X2009)) %>%             # set from numeric to character so following line works
  mutate(across(X1970:X2022, ~na_if(., "Null"))) %>%  # replace any "Null" to NA 
  rename(original_id = ID) %>%      # set "ID" to original_id, and make a new ID corresponding to rownumber to avoid issues
  mutate(ID = row_number()) %>% 
  rename(Taxa = Taxonomic_group) %>%                      # rename this column to Taxa
  mutate(Taxa = case_when(Taxa=="Mammalia" ~ "Mammals",   # rename these redundant labels
                          Taxa=="Reptilia" ~ "Herps", 
                          TRUE ~ Taxa))

# save (original) data with zeros 
cad_z <- cad 

# change all zeros to NA in population abundance columns (ie. X1970-X2022 values)
cad <- cad %>% 
  mutate(case_when(if_any(X1970:X2022, ~. ==0) ~ NA, 
                         TRUE ~ .))  # set all zeros to NA

# join binomial spp name to pop_lambdas
cad.names <- cad %>% 
  dplyr::select(ID, Binomial) %>% 
  rename(population_id = ID)


# unweighted LPI output 
u_cad <- read.csv(here("01_outdata", "unweighted-LPI.csv"), header=TRUE) %>% 
  column_to_rownames(var="X")

# population-level lambdas
pop_lambdas <- read.csv(here("01_outdata", "unweighted_pops_PopLambda.txt"), header=TRUE)
pop_lambdas <- left_join(pop_lambdas, cad.names) # add spp name to popn lambda file

# species-level lambdas
spp_lambdas <- read.csv(here("01_outdata", "unweighted_pops_lambda.csv"), header=TRUE) 



##### DELETE/MODIFY????

# 
# # load LPIMain output data
# lpi_out <- read.csv(here("02_outdata", "Group3_Confidence-Intervals", "LPI-sensitivity_conf-int_CAD-unweighted-year-CIs.csv"), header=TRUE) 
# 
# # load df with information on zeros
# cad_zeros <- read.csv(here("02_outdata", "Group3_Confidence-Intervals", "CAD_data_zeros.csv"), header=TRUE) 



```

## table of contents

section 0: run LPI

-   0.1: run unweighted CAD-LPI
-   0.2: run weighted CAD-LPI

section 1: code

-   1.1: confidence intervals
-   1.1.1: calculate confidence intervals via 3 approaches (bootstrap by populations, species, and years)
-   1.1.2: boxplot of confidence interval range for 3 approaches
-   1.2: weighting trend comparison
-   1.3: baseline
-   1.3.1: run CAD LPI with various baseline years & measure average rate of change
-   1.3.2: boxplot of average rate of change across baselines
-   1.4: log-linear vs linear modelling

section 2: manuscript figures (primary & supplementary)

## section 0: run LPI + tidy

***NOTE: This code is commented out after running the first time so it does not re-run every time the document is knit. Only re-run if necessary to make modifications, otherwise use LPI outputs.***

### 0.1: run unweighted CAD-LPI

NOTE: this chunk should not be re-run every time! instead, the output should be saved after the initial run & re-loaded into the document.
```{r, eval=FALSE}
# create infile
infile_u <- create_infile(cad,
                          start_col_name = "X1970",  # data start year
                          end_col_name = "X2022",    # data end year
                          CUT_OFF_YEAR = 1970,       # filters all data out existing before this year
                          name = "./01_outdata/unweighted") # name the infile/outputs

# run LPIMain
u_cad <- LPIMain(infile_u,
                 REF_YEAR = 1970,
                 PLOT_MAX=2022,
                 LINEAR_MODEL_SHORT_FLAG = TRUE,
                 BOOT_STRAP_SIZE = 10000, 
                 DATA_LENGTH_MIN = 3,
                 VERBOSE=TRUE, 
                 SHOW_PROGRESS =FALSE, 
                 force_recalculation = 1)

# make rownames (year) to separate col
u_cad <- u_cad %>% 
  mutate(year = as.numeric(rownames(.))) %>%   # set year as a numeric class
  filter(!year==2023)                          # remove this--we only want till 2022
rownames(u_cad) <- u_cad$year

# save file 
write.csv(u_cad,file.path("01_outdata","unweighted-LPI.csv"))
```

### 0.2: run weighted CAD-LPI

## section 1: code

### 1.1: confidence intervals

#### 1.1.1: calculate confidence intervals via 3 approaches

The purpose of this script is to run three methods of bootstrapping confidence intervals on the canadian LPI subset. Bootstrapping occurs on unweighted data by population (ie. bootstrapping of population-level lambda values by row), species (ie. bootstrapping of species-level lambda values by row), and within years (ie. bootstrapping of species-level lambda values for a given year).

By population:
```{r, results="hide"}
# LPIs are bootstrapped *with replacement* for each species in the dataset

# run the function to resample with replacement 10,000 times
boot_pop <- bootstrap_by_rows(pop_lambdas, species_column_name="Binomial" , start_col_name="X1970",end_col_name="X2022", iter=TRUE , N=10000)
boot_pop_CI <- as.data.frame(boot_pop$interval_data) # save CI intervals in a separate object
boot_pop_CI$year <- as.numeric(boot_pop_CI$year) # change year from character to numeric

# save data to csv
# only needs to be saved the first time this code is run!
# write.csv(boot_pop_CI, file.path("01_outdata", "unweighted-pop-CIs.csv"))

# what was CI range in 2022? 
boot_pop_CI %>% 
  filter(year==2022)
# range = Upper_CI - Lower_CI = 1.125204 - 0.8969978 = 0.2282062
```

```{r, echo=FALSE}
# tidy
boot_pop_df <- boot_pop_CI %>% 
  dplyr::select(year, Upper_CI, Lower_CI) %>% 
  rename(CI_high = Upper_CI,
         CI_low = Lower_CI) %>% 
  left_join(., u_cad %>% 
              dplyr::select(year, LPI_final), 
            by="year") %>% 
  column_to_rownames(var="year")

# plot
ggplot_lpi(boot_pop_df, col="#c1e6db", line_col = "#66C2A5")
```

By species:
```{r, results="hide"}
# LPIs are bootstrapped *with replacement* for each species in the dataset

# run the function to resample with replacement 10,000 times
boot_spp <- bootstrap_by_rows(spp_lambdas, species_column_name="Binomial" , start_col_name="X1970",end_col_name="X2022", iter=TRUE , N=10000)
boot_spp_CI <- as.data.frame(boot_spp$interval_data) # save CI intervals in a separate object
boot_spp_CI$year <- as.numeric(boot_spp_CI$year ) # change year from character to numeric

# save data to csv
# only needs to be saved the first time this code is run!
# write.csv(boot_spp_CI, file.path("01_outdata", "unweighted-species-CIs.csv"))

# what was CI range in 2022? 
boot_spp_CI %>% 
  filter(year==2022)
# range = Upper_CI - Lower_CI = 1.138598 - 0.8974167 = 0.2411813
```

```{r, echo=FALSE}
# tidy
boot_spp_df <- boot_spp_CI %>% 
  dplyr::select(year, Upper_CI, Lower_CI) %>% 
  rename(CI_high = Upper_CI,
         CI_low = Lower_CI) %>% 
  left_join(., u_cad %>% 
              dplyr::select(year, LPI_final), 
            by="year") %>% 
  column_to_rownames(var="year")

# plot
ggplot_lpi(boot_spp_df, col="#fdd1c0", line_col = "#FC8D62")
```

By year:
```{r, echo=FALSE}
# plot
ggplot_lpi(u_cad, col="#d1d9ea", line_col = "#8DA0CB")

# what was CI range in 2022? 
u_cad %>% 
  filter(year==2022)
# range = CI_high - CI_low = 1.076835 - 0.9520451 = 0.1247899
```

Compare all 3 methods:
```{r, echo=FALSE}
# create plot
cad_boot_CIs <- ggplot_multi_lpi(list(boot_pop_df, boot_spp_df, u_cad), 
                 names=c("population bootstrap", "species bootstrap", "year bootstrap"), 
                 col="Set2", 
                 facet=TRUE) +
  guides(col="none", fill="none") +
  theme(text = element_text(size=20), 
        axis.text.x = element_text(size=12)); cad_boot_CIs

# plot 
cad_boot_CIs

# save plot
ggsave(here("03_figures", "CI-3-methods.png"), cad_boot_CIs, width=8,height=5)
```


#### 1.1.2: boxplot of confidence interval range for 3 approaches

```{r}
# modified from maria's script (file = LPI-sensitivity_Group3_compare-intervals.R) 

data_folder_path <- "./01_outdata"

# create method labels
bootstrap_method_label <- c("year bootstrap",
                            "species bootstrap",
                            "population bootstrap")#,
# "GAM_data")

# assign column labels
col_labs <- list(c("year","CI_low","CI_high"),
                 c("year","Lower_CI","Upper_CI"),
                 c("year","Lower_CI","Upper_CI"))

# assign paths for each method file
bootstrap_method_output_path <- c(file.path(data_folder_path,"unweighted-LPI.csv"),
                                  file.path(data_folder_path,"unweighted-pop-CIs.csv"),
                                  file.path(data_folder_path,"unweighted-species-CIs.csv"))

# read bootstrap data and assign method name
l_bootstrap_data <- map2(bootstrap_method_output_path, col_labs, 
                         ~read_csv(.x) |> 
                           select(contains(.y)) |> 
                           setNames(c("Year","Lower_CI","Upper_CI"))) |> 
  setNames(bootstrap_method_label)

# convert to dataframe
df_bootstrap_data <- l_bootstrap_data |> bind_rows(.id="method")
df_bootstrap_data_range <- df_bootstrap_data |> mutate(range=Upper_CI-Lower_CI)

# create boxplot
img_bootstrap_methods_boxplot <- ggplot(df_bootstrap_data_range, aes(x=method,y=range)) + 
  geom_boxplot() + 
  theme_classic() + 
  ylab("Confidence Interval Range") + 
  xlab("Bootstrap Method") + 
  theme(text = element_text(size=20)) +
  #scale_fill_manual(values = c("#c1e6db", "#fdd1c0", "#d1d9ea")) + 
  guides(fill="none");img_bootstrap_methods_boxplot

# to save file 
ggsave(here("03_figures", "CI-range-boxplot.png"), img_bootstrap_methods_boxplot, height=7, width=9)
```



### 1.2: weighted vs unweighted trend comparison

### 1.3: shifting baselines

#### 1.3.1: compare trend lines (linear & log linear methods)

Set up directories and infiles:
```{r, results="hide", message=FALSE, warning=FALSE}
# set year range
ini_year <- 1970
fin_year <- 2022
years <- seq(ini_year,fin_year-5,5) # create options for base years until 2015 because 2020 left with only 2 years of data
folders <- c(file.path("01_outdata/baseline_years", years, "linear"), file.path("01_outdata/baseline_years", years, "loglinear"))

## Create directories for pops_lambda files for each year groups
map(folders, \(x) ifelse(!dir.exists(x),dir.create(x, recursive=TRUE),print("Dir exists")))

# save the files: data_infile and data_pops from create_infile to folders by years to run LPIMain on each one
# created the infile for the same year range but changed the REF_YEAR on LPIMain
system.time(map(folders, \(x) create_infile(cad,
                                            start_col_name="X1970",
                                            end_col_name = "X2022",
                                            CUT_OFF_YEAR = ini_year,
                                            name=paste0(x, "/C-LPI"))))
```

First, compute LPI where short time series are modelled using linear regression:
```{r, results="hide", message=FALSE, warning=FALSE}
# calculate LPI for each baseline (1970-2015 at 5-yr intervals)
# short time series are modelled using linear regression
baselines_linear <- map(years, \(x) LPIMain(file.path("01_outdata/baseline_years",x,"linear/C-LPI_infile.txt"),
                                            REF_YEAR = x,
                                            PLOT_MAX=2022,
                                            BOOT_STRAP_SIZE = 10000, 
                                            DATA_LENGTH_MIN = 3, 
                                            VERBOSE=TRUE, 
                                            SHOW_PROGRESS =FALSE, 
                                            force_recalculation = 1, 
                                            LINEAR_MODEL_SHORT_FLAG = TRUE))

# read in lambda files
linear_folders <- file.path("01_outdata/baseline_years", years, "linear")
baselines_linear_lambdas <- map(linear_folders, \(x) read.csv(file.path(x,"C-LPI_pops_lambda.csv"))) |>
  setNames(years)

# bootstrap each LPI baseline output by species to generate CIs
# lists to write bootstrap results to
linear_bootstrap_result <- list()
linear_bootstrap_list <- list()

# iterate the species bootstrapping over each baseline
for(i in 1:length(years)){
   linear_bootstrap_result <- bootstrap_by_rows(
    baselines_linear_lambdas[[i]],
    species_column_name = "Binomial", 
    start_col_name = paste0("X", years[i]),
    end_col_name = "X2022", 
    iter = TRUE, 
    N = 10000
   )
   linear_bootstrap_list[[i]] <- as.data.frame(linear_bootstrap_result$interval_data)
   names(linear_bootstrap_list)[i] <- paste0("spp_bootstrap_", years[i])
}

# load in lpi data
baselines_linear_df <- map(baselines_linear, \(x)  x |> rownames_to_column(var="Year")) |> setNames(years) |> bind_rows(.id="initial_year")
```

Plot LPI:
```{r, echo=FALSE}
# join lpi index data with species bootstrapped CIs
baselines_linear_plot <- map(linear_bootstrap_list, \(x)  x |> rownames_to_column(var="Year")) |> 
  setNames(years) |> 
  bind_rows(.id="initial_year") |>
  dplyr::select(initial_year, year, Lower_CI, Upper_CI) |>
  rename(Year = year) |>
  left_join(baselines_linear_df, ., by=c("initial_year", "Year")) |>
  dplyr::select(-c(CI_low, CI_high)) |> 
  mutate(Year=as.numeric(Year)) |> 
  ggplot() + 
  geom_ribbon(aes(x = Year, y = LPI_final, ymax = Upper_CI , ymin = Lower_CI,fill=as.factor(initial_year)), alpha = 0.2) +
  geom_line(aes(x = Year, y = LPI_final, colour = as.factor(initial_year)), linewidth = 0.5) + 
  ylab("Index") + coord_cartesian(ylim = c(0, 2)) +
  theme_bw() + theme(legend.position ="right",axis.text.x = element_text(angle = 90)) + 
  scale_x_continuous(breaks = seq(ini_year, fin_year, 5)) +
  scale_fill_scico_d(palette = "roma",name="Reference year") +
  scale_color_scico_d(palette = "roma",name="Reference year")+ 
  theme(text=element_text(size=20)); baselines_linear_plot
  
# ggsave(filename = "03_figures/baselines_linear_trend.png",baselines_linear_plot,width=7,height=5)
```

Next, compute LPI where short time series are modelled using log linear regression:
```{r, results="hide"}
# short time series are modelled using log linear regression
baselines_loglin <- map(years, \(x) LPIMain(file.path("01_outdata/baseline_years",x,"loglinear/C-LPI_infile.txt"),
                                            REF_YEAR = x,
                                            PLOT_MAX=2022,
                                            BOOT_STRAP_SIZE = 10000, 
                                            DATA_LENGTH_MIN = 3, 
                                            VERBOSE=TRUE, 
                                            SHOW_PROGRESS =FALSE, 
                                            force_recalculation = 1, 
                                            LINEAR_MODEL_SHORT_FLAG = FALSE))

# read in lambda files
loglin_folders <- file.path("01_outdata/baseline_years", years, "loglinear")
baselines_loglin_lambdas <- map(loglin_folders, \(x) read.csv(file.path(x,"C-LPI_pops_lambda.csv"))) |>
  setNames(years)

# bootstrap each LPI baseline output by species to generate CIs
# lists to write bootstrap results to
loglin_bootstrap_result <- list()
loglin_bootstrap_list <- list()

# iterate the species bootstrapping over each baseline
for(i in 1:length(years)){
   loglin_bootstrap_result <- bootstrap_by_rows(
    baselines_loglin_lambdas[[i]],
    species_column_name = "Binomial", 
    start_col_name = paste0("X", years[i]),
    end_col_name = "X2022", 
    iter = TRUE, 
    N = 10000
   )
   loglin_bootstrap_list[[i]] <- as.data.frame(loglin_bootstrap_result$interval_data)
   names(loglin_bootstrap_list)[i] <- paste0("spp_bootstrap_", years[i])
}

# load in lpi data
baselines_loglin_df <- map(baselines_loglin, \(x)  x |> rownames_to_column(var="Year")) |> setNames(years) |> bind_rows(.id="initial_year")
```

Plot LPI:
```{r, echo=FALSE}
# join lpi index data with species bootstrapped CIs
baselines_loglin_plot <- map(loglin_bootstrap_list, \(x)  x |> rownames_to_column(var="Year")) |> 
  setNames(years) |> 
  bind_rows(.id="initial_year") |>
  dplyr::select(initial_year, year, Lower_CI, Upper_CI) |>
  rename(Year = year) |>
  left_join(baselines_loglin_df, ., by=c("initial_year", "Year")) |>
  dplyr::select(-c(CI_low, CI_high)) |> 
  mutate(Year=as.numeric(Year)) |> 
  ggplot() + 
  geom_ribbon(aes(x = Year, y = LPI_final, ymax = Upper_CI , ymin = Lower_CI,fill=as.factor(initial_year)), alpha = 0.2) +
  geom_line(aes(x = Year, y = LPI_final, colour = as.factor(initial_year)), linewidth = 0.5) + 
  ylab("Index") + coord_cartesian(ylim = c(0, 2)) +
  theme_bw() + theme(legend.position ="right",axis.text.x = element_text(angle = 90)) + 
  scale_x_continuous(breaks = seq(ini_year, fin_year, 5)) +
  scale_fill_scico_d(palette = "roma",name="Reference year") +
  scale_color_scico_d(palette = "roma",name="Reference year") + 
  theme(text=element_text(size=20)); baselines_loglin_plot
  
# ggsave(filename = "03_figures/baselines_loglinear_trend.png",baselines_loglin_plot,width=7,height=5)
```

Plot both linear and log linear:
```{r, echo=FALSE}
baselines_plot <- ggarrange(baselines_linear_plot, baselines_loglin_plot + rremove("ylab"), labels="AUTO", common.legend = TRUE, vjust=0.5);baselines_plot

ggsave(here("03_figures", "baselines_plot.png"), baselines_plot, width=9, height=5)
```

#### 1.3.2: calculate mean LPI values per baseline 

For LPI using linear regression for short time series:
```{r}
# join all years run into one dataframe
baselines_linear_df <- map(baselines_linear, \(x)  x |> rownames_to_column(var="Year")) |> setNames(years) |> bind_rows(.id="initial_year")

# get mean values
baselines_linear_mean_lpi <- baselines_linear_df  |> 
  group_by(initial_year) |> 
  summarise(min_lpi = min(LPI_final),
            mean_lpi = mean(LPI_final),
            max_lpi = max(LPI_final),
            sd_lpi = sd(LPI_final))

# plot mean values 
baselines_linear_mean_lpi_boxplot <- baselines_linear_df |> 
  ggplot()  + 
  geom_boxplot(aes(x = as.factor(initial_year), y = LPI_final)) + 
  ylab("Index") + 
  xlab("Reference year") +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90)); baselines_linear_mean_lpi_boxplot

ggsave(filename = "03_figures/baselines_linear_mean_lpi_boxplot.png",baselines_linear_mean_lpi_boxplot,width=7,height=5)
```

For LPI using log linear regression for short time series:
```{r}
# join all years run into one dataframe
baselines_loglin_df <- map(baselines_loglin, \(x)  x |> rownames_to_column(var="Year")) |> setNames(years) |> bind_rows(.id="initial_year")

# get mean values
baselines_loglin_mean_lpi <- baselines_loglin_df  |> 
  group_by(initial_year) |> 
  summarise(min_lpi = min(LPI_final),
            mean_lpi = mean(LPI_final),
            max_lpi = max(LPI_final),
            sd_lpi = sd(LPI_final))

# plot mean values 
baselines_loglin_mean_lpi_boxplot <- baselines_loglin_df |> 
  ggplot()  + 
  geom_boxplot(aes(x = as.factor(initial_year), y = LPI_final)) + 
  ylab("Index") + 
  xlab("Reference year") + 
  theme_bw()+ 
  theme(axis.text.x = element_text(angle = 90)); baselines_loglin_mean_lpi_boxplot

ggsave(filename = "03_figures/baselines_loglin_mean_lpi_boxplot.png",baselines_loglin_mean_lpi_boxplot,width=7,height=5)
```

#### 1.3.3: calculate mean lambda values per baseline 

For LPI using linear regression for short time series:
```{r}
# load lambda files
baselines_linear_lambdas <- map(linear_folders, \(x) read.csv(file.path(x,"C-LPI_pops_lambda.csv")))

# create dataframe with all lambda files and convert to tidy format
baselines_linear_lambdas_df <- baselines_linear_lambdas |>
  setNames(years) |> 
  bind_rows(.id="initial_year") |> 
  dplyr::select(-X) |> 
  pivot_longer(starts_with("X"),names_to="Year",values_to="lambdas") |> 
  mutate(Year=as.numeric(gsub("X","",Year)))

# plot all lambda values 
baselines_linear_lambdas_boxplot <- ggplot(baselines_linear_lambdas_df) + 
  geom_boxplot(aes(x = as.factor(initial_year), y = lambdas)) + 
  ylab("Index") + xlab("Year") +
  theme_bw() + scale_color_discrete(name="Initial year");baselines_linear_lambdas_boxplot
# ggsave(filename = "03_figures/baselines_linear_lambdas_boxplots.png",baselines_linear_lambdas_boxplot,width=7,height=5)

# get mean values
baselines_linear_mean_lambdas <- baselines_linear_lambdas_df |> 
  group_by(initial_year,Year) |> 
  summarise(mean_lambda=mean(lambdas,na.rm=T)) |> 
  na.omit()

# plot mean lambda for each year (regardless of baseline)
baselines_linear_mean_lambdas_boxplot <- ggplot(baselines_linear_mean_lambdas |> filter(mean_lambda<1)) + # to remove initial years with 1 values
  geom_boxplot(aes(x = as.factor(initial_year), y = mean_lambda)) + 
  ylab("Mean lambda") + 
  xlab("Reference year") +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90));baselines_linear_mean_lambdas_boxplot

ggsave(filename = "03_figures/baselines_linear_mean_lambdas_boxplot.png",baselines_linear_mean_lambdas_boxplot,width=7,height=5)
```
For LPI using log linear regression for short time series:
```{r}
# load lambda files
baselines_loglin_lambdas <- map(loglin_folders, \(x) read.csv(file.path(x,"C-LPI_pops_lambda.csv")))

# create dataframe with all lambda files and convert to tidy format
baselines_loglin_lambdas_df <- baselines_loglin_lambdas |>
  setNames(years) |> 
  bind_rows(.id="initial_year") |> 
  dplyr::select(-X) |> 
  pivot_longer(starts_with("X"),names_to="Year",values_to="lambdas") |> 
  mutate(Year=as.numeric(gsub("X","",Year)))

# plot all lambda values 
baselines_loglin_lambdas_boxplot <- ggplot(baselines_loglin_lambdas_df) + 
  geom_boxplot(aes(x = as.factor(initial_year), y = lambdas)) + 
  ylab("Index") + xlab("Year") +
  theme_bw() + scale_color_discrete(name="Reference year");baselines_loglin_lambdas_boxplot
# ggsave(filename = "03_figures/baselines_loglin_lambdas_boxplots.png",baselines_loglin_lambdas_boxplot,width=7,height=5)

# get mean values
baselines_loglin_mean_lambdas <- baselines_loglin_lambdas_df |> 
  group_by(initial_year,Year) |> 
  summarise(mean_lambda=mean(lambdas,na.rm=T)) |> 
  na.omit()

# plot mean lambda for each year (regardless of baseline)
baselines_loglin_mean_lambdas_boxplot <- ggplot(baselines_loglin_mean_lambdas |> filter(mean_lambda<1)) + # to remove initial years with 1 values
  geom_boxplot(aes(x = as.factor(initial_year), y = mean_lambda)) + 
  ylab("Mean lambda") + 
  xlab("Reference year") +
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 90));baselines_loglin_mean_lambdas_boxplot

ggsave(filename = "03_figures/baselines_loglin_mean_lambdas_boxplot.png",baselines_loglin_mean_lambdas_boxplot,width=7,height=5)
```

Plot mean lambda & LPI index values for both linear & log linear modelling
```{r, echo=FALSE}
# specify y axis format so it plots the sample btwn boxes
y_axis_settings_1 <- scale_y_continuous(
  breaks = seq(0.95, 1.075, by = 0.025),  # example breaks, adjust as needed
  limits = c(0.95, 1.075)              # example limits, adjust as needed
)

y_axis_settings_2 <- scale_y_continuous(
  breaks = seq(-0.015, 0.015, by = 0.005),  # Example breaks, adjust as needed
  limits = c(-0.015, 0.015)              # Example limits, adjust as needed
)

# code plot
baselines_mean_lambda_lpi_boxplots <- ggarrange(baselines_linear_mean_lpi_boxplot+rremove("xlab") + 
                                                  y_axis_settings_1 + 
                                                  theme(plot.margin = margin(20, 5, 5, 5)),
                                                baselines_loglin_mean_lpi_boxplot + 
                                                  rremove("xlab") + 
                                                  rremove("ylab") + 
                                                  y_axis_settings_1 + 
                                                  theme(plot.margin = margin(20, 5, 5, 5)),
                                                baselines_linear_mean_lambdas_boxplot+y_axis_settings_2 +
                                                  theme(plot.margin = margin(20, 5, 5, 5)),
                                            baselines_loglin_mean_lambdas_boxplot + rremove("ylab") + 
                                              y_axis_settings_2 + 
                                              theme(plot.margin = margin(20, 5, 5, 5)), 
                                            labels="AUTO",
                                            widths = c(1, 1, 1, 1),  # control relative widths
                                            heights = c(1, 1)  # control relative heights
                                            );baselines_mean_lambda_lpi_boxplots    

# save plot
ggsave(here("03_figures", "baselines_mean_lambda_lpi_boxplots.png"), baselines_mean_lambda_lpi_boxplots, height=5, width=7)
```


### 1.4: modelling decisions: log-linear vs linear vs GAM

Here we investigate how various modelling decisions affect the LPI trend line. In the first case, short time series (<6 data points) are modelled in a log linear regression and longer time series (≥6 data points) are modelled using a general additive model (GAM). In the second case, short time series are modelled using a linear regression and longer time series are modelled using a GAM. We also compared this to a case where all time series, regardless of length, were modelled using a GAM. Note that time series with only 2 data points are excluded from all analyses. Confidence intervals use the species bootstrapping method as in section 1.1.

#### 1.4.1: process data

LPI output where short time series (<6 points) are modelled as log-linear & long time series (>=6 points) are modelled as GAM: 
```{r, results="hide"}
# create infile 
infile_loglin <- create_infile(cad,
                          start_col_name = "X1970",  # data start year
                          end_col_name = "X2022",    # data end year
                          CUT_OFF_YEAR = 1970,       # filters all data out existing before this year
                          name = "./01_outdata/loglin") # name the infile/outputs

# run LPI 
lpi_lm_false <- LPIMain(infile_loglin, 
                        REF_YEAR = 1970,
                        PLOT_MAX=2022,
                        BOOT_STRAP_SIZE = 10000, 
                        DATA_LENGTH_MIN = 3, 
                        VERBOSE=TRUE, 
                        SHOW_PROGRESS =FALSE, 
                        force_recalculation = 1,
                        LINEAR_MODEL_SHORT_FLAG = FALSE)

# read in species lambda file 
spp_lambdas_loglin <- read.csv(here("01_outdata", "loglin_pops_lambda.csv"), header=TRUE) 

# bootstrap by species to get CIs for lpi_lm_false
boot_spp_loglin <- bootstrap_by_rows(spp_lambdas_loglin, species_column_name="Binomial" , start_col_name="X1970",end_col_name="X2022", iter=TRUE , N=10000)
boot_spp_loglin <- as.data.frame(boot_spp_loglin$interval_data) # save CI intervals in a separate object
boot_spp_loglin$year <- as.numeric(boot_spp_loglin$year) # change year from character to numeric

boot_spp_loglin_df <- boot_spp_loglin %>% 
  dplyr::select(year, Upper_CI, Lower_CI) %>% 
  rename(CI_high = Upper_CI,
         CI_low = Lower_CI) %>% 
  left_join(., 
            lpi_lm_false %>% 
              rownames_to_column(var="year") %>% 
              dplyr::select(year, LPI_final) %>% 
              filter(!year==2023) %>% 
              mutate(year = as.numeric(year)), 
            by="year") %>% 
  column_to_rownames(var="year")
```

LPI output where short time series (<6 points) are modelled as linear & long time series (>=6 points) are modelled as GAM:
```{r, results="hide"}
# create infile 
infile_lin <- create_infile(cad,
                          start_col_name = "X1970",  # data start year
                          end_col_name = "X2022",    # data end year
                          CUT_OFF_YEAR = 1970,       # filters all data out existing before this year
                          name = "./01_outdata/lin") # name the infile/outputs

# run LPI 
lpi_lm_true <- LPIMain(infile_lin, 
                        REF_YEAR = 1970,
                        PLOT_MAX=2022,
                        BOOT_STRAP_SIZE = 10000, 
                        DATA_LENGTH_MIN = 3, 
                        VERBOSE=TRUE, 
                        SHOW_PROGRESS =FALSE, 
                        force_recalculation = 1,
                        LINEAR_MODEL_SHORT_FLAG = TRUE)

# read in species lambda file 
spp_lambdas_lin <- read.csv(here("01_outdata", "lin_pops_lambda.csv"), header=TRUE) 

# bootstrap by species to get CIs for lpi_lm_false
boot_spp_lin <- bootstrap_by_rows(spp_lambdas_lin, species_column_name="Binomial" , start_col_name="X1970",end_col_name="X2022", iter=TRUE , N=10000)
boot_spp_lin <- as.data.frame(boot_spp_lin$interval_data) # save CI intervals in a separate object
boot_spp_lin$year <- as.numeric(boot_spp_lin$year) # change year from character to numeric

boot_spp_lin_df <- boot_spp_lin %>% 
  dplyr::select(year, Upper_CI, Lower_CI) %>% 
  rename(CI_high = Upper_CI,
         CI_low = Lower_CI) %>% 
  left_join(., lpi_lm_true %>% 
              rownames_to_column(var="year") %>% 
              dplyr::select(year, LPI_final) %>% 
              filter(!year==2023) %>% 
              mutate(year = as.numeric(year)),
              by="year") %>% 
  column_to_rownames(var="year")
```

LPI output where all time series, regardless of length, are modelled as GAM:
```{r, results="hide"}
# create infile 
infile_gam <- create_infile(cad,
                          start_col_name = "X1970",  # data start year
                          end_col_name = "X2022",    # data end year
                          CUT_OFF_YEAR = 1970,       # filters all data out existing before this year
                          name = "./01_outdata/gam") # name the infile/outputs

# run LPI where all time series (regardless of length) are modelled as GAM
lpi_gam <- LPIMain(infile_gam, 
                   REF_YEAR = 1970,
                   PLOT_MAX=2022,
                   BOOT_STRAP_SIZE = 10000, 
                   DATA_LENGTH_MIN = 3, 
                   VERBOSE=TRUE, 
                   SHOW_PROGRESS =FALSE, 
                   force_recalculation = 1,
                   GLOBAL_GAM_FLAG_SHORT_DATA_FLAG = TRUE)

# read in species lambda file 
spp_lambdas_gam <- read.csv(here("01_outdata", "gam_pops_lambda.csv"), header=TRUE) 

# bootstrap by species to get CIs for lpi_lm_false
boot_spp_gam <- bootstrap_by_rows(spp_lambdas_gam, species_column_name="Binomial" , start_col_name="X1970",end_col_name="X2022", iter=TRUE , N=10000)
boot_spp_gam <- as.data.frame(boot_spp_gam$interval_data) # save CI intervals in a separate object
boot_spp_gam$year <- as.numeric(boot_spp_gam$year) # change year from character to numeric

boot_spp_gam_df <- boot_spp_gam %>% 
  dplyr::select(year, Upper_CI, Lower_CI) %>% 
  rename(CI_high = Upper_CI,
         CI_low = Lower_CI) %>% 
  left_join(., lpi_gam %>% 
              rownames_to_column(var="year") %>% 
              dplyr::select(year, LPI_final) %>% 
              filter(!year==2023) %>% 
              mutate(year = as.numeric(year)),
              by="year") %>% 
  column_to_rownames(var="year")
```

#### 1.4.2: plot
```{r, echo=FALSE}
# plot 
lpi_model_versions <- ggplot_multi_lpi(list(boot_spp_loglin_df, boot_spp_lin_df, boot_spp_gam_df), 
                 names=c("log linear (<6 points)", "linear (<6 points)", "GAM"), 
                 col="Set1", 
                 facet=TRUE) + 
  guides(fill="none", colour="none") + 
  theme(text = element_text(size=20), 
        axis.text.x = element_text(size=12))

lpi_model_versions

ggsave(here("03_figures", "lpi-model-versions.png"), lpi_model_versions, width=8, height=5)
```

#### 1.4.3: summary statistics 
How many populations are modelled using a GAM (≥6 data points in time series), and how many using linear/log linear regression (<6 data points). 
```{r}
pt_counts <- cad %>% 
  mutate(num.datapoints = rowSums(!is.na(select(., X1970:X2022))))

length(which(pt_counts$num.datapoints<6)) # 1833 time series have less than 6 data points
length(which(pt_counts$num.datapoints>=6)) # 2660 time series have 6 or more data points
```



### 1.5: short/sparse time series
#### 1.5.0: subset & tidy
First calculate number of data points, period, and completeness for each time series. 

```{r number of data points, results="hide"}
#calculate number of data points (number of years for each time series that have population abundances)
cad2 <- cad %>% 
  mutate(num.datapoints = rowSums(!is.na(select(., X1970:X2022)))) 
```

For time series with ≥15 points: 
```{r, results="hide"}
greaterthan15points.lpidata <- subset(cad2, num.datapoints >= 15)
nrow(greaterthan15points.lpidata) # 1288

#this calculates the start year, end year, and period (length) of each time series
period_greaterthan15points <- matrix(NA, nrow = nrow(greaterthan15points.lpidata), ncol = 3)

for (i in 1:nrow(period_greaterthan15points)){
  period_greaterthan15points[i,1] <-min(which(!is.na(greaterthan15points.lpidata[i,13:65])))
  period_greaterthan15points[i,2] <-max(which(!is.na(greaterthan15points.lpidata[i,13:65])))
  period_greaterthan15points[i,3] <- period_greaterthan15points[i,2]-period_greaterthan15points[i,1]+1
}

#name and merge them into the dataset
colnames(period_greaterthan15points) <- c("start.year", "end.year", "period")

greaterthan15points.lpidata <- cbind(greaterthan15points.lpidata, period_greaterthan15points)

#calculate a completeness proportion (number of years sampled per length)
greaterthan15points.lpidata$completeness <- greaterthan15points.lpidata$num.datapoints / greaterthan15points.lpidata$period

# #create a random subsample for testing
# random_sample_size_10 <- round(nrow(greaterthan15points.lpidata)*subsample.prop)
```

For time series with ≥6 points: 
```{r, results="hide"}
greaterthan6points.lpidata <- subset(cad2, num.datapoints >= 6)
nrow(greaterthan6points.lpidata) # 2660

#this calculates the start year, end year, and period (length) of each time series
period_greaterthan6points <- matrix(NA, nrow = nrow(greaterthan6points.lpidata), ncol = 3)

for (i in 1:nrow(period_greaterthan6points)){
  period_greaterthan6points[i,1] <-min(which(!is.na(greaterthan6points.lpidata[i,13:65])))
  period_greaterthan6points[i,2] <-max(which(!is.na(greaterthan6points.lpidata[i,13:65])))
  period_greaterthan6points[i,3] <- period_greaterthan6points[i,2]-period_greaterthan6points[i,1]+1
}

#name and merge them into the dataset
colnames(period_greaterthan6points) <- c("start.year", "end.year", "period")

greaterthan6points.lpidata <- cbind(greaterthan6points.lpidata, period_greaterthan6points)

#calculate a completeness proportion (number of years sampled per length)
greaterthan6points.lpidata$completeness <- greaterthan6points.lpidata$num.datapoints / greaterthan6points.lpidata$period
```

For time series with ≥3 points: 
```{r, results="hide"}
greaterthan3points.lpidata <- subset(cad2, num.datapoints >= 3)
nrow(greaterthan3points.lpidata) # 3473

#this calculates the start year, end year, and period (length) of each time series
period_greaterthan3points <- matrix(NA, nrow = nrow(greaterthan3points.lpidata), ncol = 3)

for (i in 1:nrow(period_greaterthan3points)){
  period_greaterthan3points[i,1] <-min(which(!is.na(greaterthan3points.lpidata[i,13:65])))
  period_greaterthan3points[i,2] <-max(which(!is.na(greaterthan3points.lpidata[i,13:65])))
  period_greaterthan3points[i,3] <- period_greaterthan3points[i,2]-period_greaterthan3points[i,1]+1
}

#name and merge them into the dataset
colnames(period_greaterthan3points) <- c("start.year", "end.year", "period")

greaterthan3points.lpidata <- cbind(greaterthan3points.lpidata, period_greaterthan3points)

#calculate a completeness proportion (number of years sampled per length)
greaterthan3points.lpidata$completeness <- greaterthan3points.lpidata$num.datapoints / greaterthan3points.lpidata$period
```

For time series with ≥2 points: 
```{r, results="hide"}
greaterthan2points.lpidata <- subset(cad2, num.datapoints >= 2)
nrow(greaterthan2points.lpidata) # 4145

#this calculates the start year, end year, and period (length) of each time series
period_greaterthan2points <- matrix(NA, nrow = nrow(greaterthan2points.lpidata), ncol = 3)

for (i in 1:nrow(period_greaterthan2points)){
  period_greaterthan2points[i,1] <-min(which(!is.na(greaterthan2points.lpidata[i,13:65])))
  period_greaterthan2points[i,2] <-max(which(!is.na(greaterthan2points.lpidata[i,13:65])))
  period_greaterthan2points[i,3] <- period_greaterthan2points[i,2]-period_greaterthan2points[i,1]+1
}

#name and merge them into the dataset
colnames(period_greaterthan2points) <- c("start.year", "end.year", "period")

greaterthan2points.lpidata <- cbind(greaterthan2points.lpidata, period_greaterthan2points)

#calculate a completeness proportion (number of years sampled per length)
greaterthan2points.lpidata$completeness <- greaterthan2points.lpidata$num.datapoints / greaterthan2points.lpidata$period
```

#### 1.5.1: how does number of data points impact the LPI?

Decision 1: How does the number of data points (times in which population abundance was assessed) impact the LPI?
options: at least 2, at least 3 (to match what WWF-Canada currently does), at least 6 (to include only the populations modelled via GAMs), and at least 15 (just to see what a much larger number does)


Calculate the LPI for each category, i.e. time series with >=2, >=3, >=6, >=15 datapoints:
```{r, results="hide"}
# calculate LPI for time series with at least 15 datapoints
subset_lpi_15 <- LPIMain(create_infile(greaterthan15points.lpidata,
                                              name="01_outdata/15pts+_data",
                                              start_col_name = "X1970",
                                              end_col_name = "X2022",
                                              CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
BOOT_STRAP_SIZE = 10000,
VERBOSE=FALSE, 
PLOT_MAX=2022,
LINEAR_MODEL_SHORT_FLAG = 1,
#DATA_LENGTH_MIN = 3,
force_recalculation = 1
)

# calculate LPI for time series with at least 6 datapoints
subset_lpi_6 <- LPIMain(create_infile(greaterthan6points.lpidata,
                                              name="01_outdata/6pts+_data",
                                              start_col_name = "X1970",
                                              end_col_name = "X2022",
                                              CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
BOOT_STRAP_SIZE = 10000,
VERBOSE=FALSE, 
PLOT_MAX=2022,
LINEAR_MODEL_SHORT_FLAG = 1,
#DATA_LENGTH_MIN = 3,
force_recalculation = 1
)

# calculate LPI for time series with at least 3 datapoints
subset_lpi_3 <- LPIMain(create_infile(greaterthan3points.lpidata,
                                              name="01_outdata/3pts+_data",
                                              start_col_name = "X1970",
                                              end_col_name = "X2022",
                                              CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
BOOT_STRAP_SIZE = 10000,
VERBOSE=FALSE, 
PLOT_MAX=2022,
LINEAR_MODEL_SHORT_FLAG = 1,
# DATA_LENGTH_MIN = 3,
force_recalculation = 1
)

# calculate LPI for time series with at least 2 datapoints
subset_lpi_2 <- LPIMain(create_infile(greaterthan2points.lpidata,
                                              name="01_outdata/2pts+_data",
                                              start_col_name = "X1970",
                                              end_col_name = "X2022",
                                              CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
BOOT_STRAP_SIZE = 10000,
VERBOSE=FALSE,
PLOT_MAX=2022,
LINEAR_MODEL_SHORT_FLAG = 1,
# DATA_LENGTH_MIN = 3,
force_recalculation = 1
)

# remove 2023
subset_lpi_15 <- subset_lpi_15[1:53,]
subset_lpi_6 <- subset_lpi_6[1:53,]
subset_lpi_3 <- subset_lpi_3[1:53,]
subset_lpi_2 <- subset_lpi_2[1:53,]
```

Plot all four scenarios (>=15, >=6, >=3, or >=2 datapoints) together
```{r plot of number of data points}
# order names so it plots in logical order
namesvec <- c("≥2 data points", "≥3 data points", "≥6 data points", "≥15 data points")
namesvec <- factor(namesvec, levels=c("≥2 data points", "≥3 data points", "≥6 data points", "≥15 data points"))

# code plot
num_datapts_plot <- ggplot_multi_lpi(list(subset_lpi_2, subset_lpi_3, subset_lpi_6, subset_lpi_15), 
                                     names = namesvec, 
                                     facet=TRUE) +
  guides(col="none", fill="none") +
  theme(text = element_text(size=20), 
        axis.text.x = element_text(size=12));num_datapts_plot

# save plot
ggsave(here("03_figures", "num-data-pts.png"), num_datapts_plot, width=8,height=5)
```

#### 1.5.2: how does completeness of time series impact the LPI?

sandra's note: Currently this is running on all the data, but eventually we should split this up into the subsets of data based on number of data points (i.e. 2 data points in 2 years is not comparable to 40 data points in 40 years).

```{r completeness, results="hide"}
# subset data
greaterthan75complete.lpidata <- subset(greaterthan3points.lpidata, completeness > 0.75)
greaterthan50complete.lpidata <- subset(greaterthan3points.lpidata, completeness > 0.5)
greaterthan25complete.lpidata <- subset(greaterthan3points.lpidata, completeness > 0.25)
greaterthan0complete.lpidata <- subset(greaterthan3points.lpidata, completeness > 0)

# how many time series are included in each subset?
nrow(greaterthan75complete.lpidata) # 1994
nrow(greaterthan50complete.lpidata) # 2815
nrow(greaterthan25complete.lpidata) # 3344
nrow(greaterthan0complete.lpidata) # 3473

# run LPI for each subset
completeness75.lpi <- LPIMain(create_infile(greaterthan75complete.lpidata,
                                            name="01_outdata/75+complete_data",
                                            start_col_name = "X1970",
                                            end_col_name = "X2022",
                                            CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
PLOT_MAX = 2022,
BOOT_STRAP_SIZE = 10000,
# DATA_LENGTH_MIN = 3,     # commented out, since we've already done this manually
VERBOSE=FALSE, 
LINEAR_MODEL_SHORT_FLAG = 1,
force_recalculation = 1
)

completeness50.lpi <- LPIMain(create_infile(greaterthan50complete.lpidata,
                                            name="01_outdata/50+complete_data",
                                            start_col_name = "X1970",
                                            end_col_name = "X2022",
                                            CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
PLOT_MAX = 2022,
BOOT_STRAP_SIZE = 10000,
# DATA_LENGTH_MIN = 3,     # commented out, since we've already done this manually
VERBOSE=FALSE, 
LINEAR_MODEL_SHORT_FLAG = 1,
force_recalculation = 1
)

completeness25.lpi <- LPIMain(create_infile(greaterthan25complete.lpidata,
                                            name="01_outdata/25+complete_data",
                                            start_col_name = "X1970",
                                            end_col_name = "X2022",
                                            CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
PLOT_MAX = 2022,
BOOT_STRAP_SIZE = 10000,
# DATA_LENGTH_MIN = 3,     # commented out, since we've already done this manually
VERBOSE=FALSE, 
LINEAR_MODEL_SHORT_FLAG = 1,
force_recalculation = 1
)

completeness0.lpi <- LPIMain(create_infile(greaterthan0complete.lpidata,
                                           name="01_outdata/0+complete_data",
                                           start_col_name = "X1970",
                                           end_col_name = "X2022",
                                           CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
PLOT_MAX = 2022,
BOOT_STRAP_SIZE = 10000,
# DATA_LENGTH_MIN = 3,     # commented out, since we've already done this manually
VERBOSE=FALSE, 
LINEAR_MODEL_SHORT_FLAG = 1,
force_recalculation = 1
)

# remove 2023
completeness75.lpi <- completeness75.lpi[1:53,]
completeness50.lpi <- completeness50.lpi[1:53,]
completeness25.lpi <- completeness25.lpi[1:53,]
completeness0.lpi <- completeness0.lpi[1:53,]
```

Plot all four scenarios (75%, 50%, 25%, 0% completeness) together:
```{r, echo=FALSE}
# code plot
completeness_plot <- ggplot_multi_lpi(list(completeness75.lpi, completeness50.lpi, completeness25.lpi, completeness0.lpi),
                                      names = c(">75% complete", ">50% complete", ">25% complete", ">0% complete"), 
                                      facet=TRUE) +
  guides(col="none", fill="none") +
  theme(text = element_text(size=20), 
        axis.text.x = element_text(size=12))

# plot
completeness_plot

# save plot
ggsave(here("03_figures", "completeness.png"), completeness_plot, width=8,height=5)
```
#### 1.5.3: how does time series period impact the LPI?

``` {r period, results="hide"}
# subset data by period
greaterthan10period.lpidata <- subset(greaterthan2points.lpidata, period >= 10)
greaterthan5period.lpidata <- subset(greaterthan2points.lpidata, period >= 5)
greaterthan2period.lpidata <- subset(greaterthan2points.lpidata, period >= 2)

# how many time series are included in each subset?
nrow(greaterthan10period.lpidata) # 2694
nrow(greaterthan5period.lpidata) # 3370
nrow(greaterthan2period.lpidata) # 4145

period10.lpi <- LPIMain(create_infile(greaterthan10period.lpidata,
                                      name="01_outdata/>10period_data",
                                      start_col_name = "X1970",
                                      end_col_name = "X2022",
                                      CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
PLOT_MAX = 2022,
BOOT_STRAP_SIZE = 10000,
# DATA_LENGTH_MIN = 3,     # commented out, since we've already done this manually
VERBOSE=FALSE, 
LINEAR_MODEL_SHORT_FLAG = 1,
force_recalculation = 1
)

period5.lpi <- LPIMain(create_infile(greaterthan5period.lpidata,
                                     name="01_outdata/>5period_data",
                                     start_col_name = "X1970",
                                     end_col_name = "X2022",
                                     CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
PLOT_MAX = 2022,
BOOT_STRAP_SIZE = 10000,
# DATA_LENGTH_MIN = 3,     # commented out, since we've already done this manually
VERBOSE=FALSE, 
LINEAR_MODEL_SHORT_FLAG = 1,
force_recalculation = 1
)


period2.lpi <- LPIMain(create_infile(greaterthan2period.lpidata,
                                     name="01_outdata/>2period_data",
                                     start_col_name = "X1970",
                                     end_col_name = "X2022",
                                     CUT_OFF_YEAR = 1970
),
REF_YEAR = 1970,
PLOT_MAX = 2022,
BOOT_STRAP_SIZE = 10000,
# DATA_LENGTH_MIN = 3,     # commented out, since we've already done this manually
VERBOSE=FALSE, 
LINEAR_MODEL_SHORT_FLAG = 1,
force_recalculation = 1
)
```

Plot all three scenarios (>10 year, >5 year, >2 year period) together:
```{r, echo=FALSE}
# order names so it plots in logical order
namesvec <- c("≥10 year period", "≥5 year period", "≥2 year period")
namesvec <- factor(namesvec, levels=c("≥2 year period", "≥5 year period", "≥10 year period"))

# code plot
period_plot <- ggplot_multi_lpi(list(period10.lpi, period5.lpi, period2.lpi),
                 names = namesvec,
                 facet=TRUE) +
  guides(col="none", fill="none") +
  theme(text = element_text(size=20), 
        axis.text.x = element_text(size=12)); period_plot

# save plot
ggsave(here("03_figures", "period.png"), period_plot, width=8,height=5)
```


### 1.6: treatment of zero values 

## section 2: manuscript figures (primary & supplementary)

supplementary: location of zeros in the dataset 
```{r, echo=FALSE}
## format the data for plot
# Calculate the nb of 0s present for each time series (ID)
nb_zeros_per_id <- cad_z %>% 
  pivot_longer(X1970:X2022, names_to = "Year") %>%
  filter(value == 0) %>%
  group_by(ID) %>%
  summarise(n0 = n())

# How many rows have 0s?
nrow(nb_zeros_per_id) # 300 out of the 4493 time series

# Compare to the total number of values for that time series (non NULL)
nb_values_per_id <- cad_z %>% 
  pivot_longer(X1970:X2022, names_to = "Year") %>%
  filter(!value == "NULL") %>%
  group_by(ID) %>%
  summarise(n = n()) 

# Getting a clean long dataset
cad_long <- cad_z %>% 
  pivot_longer(X1970:X2022, names_to = "Year")
cad_long$Year=gsub("X","",cad_long$Year) # Remove the X to only have years

## Create a zeros df 

# Create df with info on zeros for each time series (each ID)
cad_zeros <- left_join(x=nb_values_per_id,y=nb_zeros_per_id,by="ID") %>% 
  replace(is.na(.),0)
# ID = ID of the time series
# n = number of values in this time series (non NULL)
# n0 = number of zeros in this time series 

# Extracting the first non NULL value for each row
# In column data_zeros$first_value
cad_zeros <- 
  cad_long %>% 
  filter(!value == "NULL") %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  filter(row_number()==1) %>% 
  rename(first_value = Year) %>% 
  select(ID, first_value) %>% 
  left_join(x=cad_zeros,y=.,by="ID")

# Extracting the last non NULL value for each row
# In column data_zeros$last_value
cad_zeros <-
  cad_long %>% 
  filter(!value == "NULL") %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  filter(row_number()==n()) %>% 
  rename(last_value = Year) %>% 
  select(ID, last_value) %>% 
  left_join(x=cad_zeros,y=.,by="ID")

# Extracting the first ZERO value for each row
# In column data_zeros$first_zero
cad_zeros <-
  cad_long %>% 
  filter(value == 0) %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  filter(row_number()==1) %>% 
  rename(first_zero = Year) %>% 
  select(ID, first_zero) %>% 
  left_join(x=cad_zeros,y=.,by="ID")

# Extracting the last ZERO value for each row
# In column data_zeros$last_zero
cad_zeros <-
  cad_long %>% 
  filter(value == 0) %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  filter(row_number()==n()) %>% 
  rename(last_zero = Year) %>% 
  select(ID, last_zero) %>% 
  left_join(x=cad_zeros,y=.,by="ID") 

# Calculate duration of the time series (nb of years between first and last non null)
cad_zeros$duration <- as.numeric(cad_zeros$last_value)-as.numeric(cad_zeros$first_value)

# Add the animal classes from the original raw data 
cad_zeros <- cad_zeros %>% 
  left_join(x=.,y=cad[,c("ID", "Taxonomic_group")], by="ID")

# Extracting the first non ZERO value for each row
# In column data_zeros$first_non0
cad_zeros <- 
  cad_long %>% 
  filter(!value == "NULL"& !value==0) %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  filter(row_number()==1) %>% 
  rename(first_non0 = Year) %>% 
  select(ID, first_non0) %>% 
  left_join(x=cad_zeros,y=.,by="ID")

# Extracting the last non ZERO value for each row
# In column data_zeros$last_non0
cad_zeros <- 
  cad_long %>% 
  filter(!value == "NULL"& !value==0) %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  filter(row_number()==n()) %>% 
  rename(last_non0 = Year) %>% 
  select(ID, last_non0) %>% 
  left_join(x=cad_zeros,y=.,by="ID")

## Count the location of all zeros
# Number of middle, start, end for each ID

# How many middle 0s?
cad_zeros <- cad_long %>% 
  filter(!value == "NULL") %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  mutate(firstnon0 = min(row_number()[value!=0])) %>% 
  mutate(lastnon0 = max(row_number()[value!=0])) %>% 
  filter(row_number()>firstnon0 & row_number()<lastnon0) %>% 
  filter(value==0) %>% 
  summarise(nb_middle0s = n()) %>% 
  left_join(x=cad_zeros,y=.,by="ID")  # 4,856 rows with 0s in the middle of the time series

# How many start 0s?
cad_zeros <- cad_long %>% 
  filter(!value == "NULL") %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  mutate(firstnon0 = min(row_number()[value!=0])) %>% 
  filter(row_number()<firstnon0) %>% 
  summarise(nb_start0s = n()) %>% 
  left_join(x=cad_zeros,y=.,by="ID")  # Says there are 4,802 rows with 0 to start indeed. Here are how many start 0s for each row

# How many end 0s?
cad_zeros <- cad_long %>% 
  filter(!value == "NULL") %>% 
  group_by(ID) %>% 
  arrange(Year) %>% 
  mutate(lastnon0 = max(row_number()[value!=0])) %>% 
  filter(row_number()>lastnon0) %>% 
  summarise(nb_end0s = n()) %>% 
  left_join(x=cad_zeros,y=.,by="ID")  # 6,304 rows with end zeros!!

# some tidying
plot_dat <- cad_z %>%
  left_join(., cad_zeros %>% select(ID, duration, first_value, last_value), by = "ID") %>%
  #mutate_at(c("T_realm", "M_realm", "FW_realm"), ~ifelse(. == "NULL", NA, .)) %>% # Merge all the realm names together, not in 3 cols
  #mutate(realm = coalesce(T_realm, M_realm, FW_realm)) %>%
  pivot_longer(X1970:X2022, names_to = "Year") %>%
  mutate(Year = as.numeric(str_remove(Year, "X")), 
         first_value = as.numeric(first_value),
         last_value = as.numeric(last_value), 
         Taxonomic_group = case_when(Taxonomic_group=="Mammalia" ~ "Mammals",
                                     Taxonomic_group=="Reptilia" ~ "Herps",
                                     TRUE ~ Taxonomic_group)) %>% 
  filter(!(value == "NULL")) %>%
  mutate(value_label = ifelse(value == 0, "Zero", "Non Zero")) %>%
  #arrange(duration) %>%
  arrange(desc(last_value)) %>% 
  mutate(plot_row_id = row_number())

# plot 
zeros_strip_chart <- plot_dat %>% 
  ggplot(aes(x = Year, y = plot_row_id, color = value_label)) +
  geom_segment(aes(x = first_value, xend = last_value, y = plot_row_id, yend = plot_row_id),
               size = 0.1, col = "lightgrey",inherit.aes = FALSE) +
  geom_point(data=subset(plot_dat,value_label=="Non Zero"), size = 0.2) + # plot non-zero pts behind zero pts
  geom_point(data=subset(plot_dat,value_label=="Zero"), size = 0.2) + # make zero pts clearer by plotting in front
  scale_color_manual(values = c("darkgray", "red"), name="") +
  scale_x_continuous(breaks=seq(1950,2020,20)) + 
  scale_y_continuous(breaks=seq(0,60000,20000)) +
  facet_grid(System~Taxonomic_group)+
  theme_bw() +
  xlab("Year") +
  ylab("Population ID") +
  theme(strip.text = element_text(face="bold", size=12), 
        text = element_text(size=12), 
        legend.text = element_text(size=12), 
        legend.position = "top") + 
  guides(colour = guide_legend(override.aes = list(size=2)));zeros_strip_chart

ggsave(here("03_figures", "zeros_strip_chart.png"), zeros_strip_chart, height=7, width=9)
```
